* HTTP状态码    
   100  Continue	继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认,之后发送具体参数信息    
	200  OK 		正常返回信息    
	201  Created  	请求成功并且服务器创建了新资源    
	202  Accepted 	服务器已接受请求，但尚未处理   
	301  Moved Permanently  请求的网页已永久移到新位置。    
	302 Found  		临时性重定向。    
	303 See Other  	临时性重定向，且总是使用 GET请求新的 URI。    
	304  Not Modified 自从上次请求后，请求的网未修改过。    
	400 Bad Request  服务器无法理解请求的格式，户端不应当尝试再次使用相同的内容发起请求。    
	401 Unauthorized 请求未授权。    
	403 Forbidden  	禁止访问。    
	404 Not Found  	找不到如何与 URI 相匹配的源。    
	500 Internal Server Error  最常见的服务器错误。  
	503 Service Unavailable 服务器端暂时无法处请求（可能是过载或维护）。
* 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

    详细版:
1. 在浏览器地址栏输入URL
2. 浏览器查看**缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤
    1. 如果资源未缓存，发起新请求
    2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
    3. 检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
        - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
        - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3. 浏览器**解析URL**获取协议，主机，端口，path
4. 浏览器**组装一个HTTP（GET）请求报文**
5. 浏览器**获取主机ip地址**，过程如下：
    1. 浏览器缓存
    2. 本机缓存
    3. hosts文件
    4. 路由器缓存
    5. ISP DNS缓存
    6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. **打开一个socket与目标IP地址，端口建立TCP链接**，三次握手如下：
    1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
    2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
    3. 客户端发送**ACK=Y+1， Seq=Z**
7. TCP链接建立后**发送HTTP请求**
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过TCP连接发送回浏览器**
12. 浏览器接收HTTP响应，然后根据情况选择**关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下**：
    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释
18. **构建DOM树**：
    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图片、样式表、js文件，**启动下载**
20. 构建**CSSOM树**：
    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树
21. **[根据DOM树和CSSOM树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:
    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    3. 发布可视节点的内容和计算样式
22. **js解析如下**：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，document.readState变成interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
    6. 浏览器**在Document对象上触发DOMContentLoaded事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState变为complete,window触发load事件
23. **显示页面**（HTML解析过程中会逐步显示页面）

   > * 简洁版:    
  	1. 浏览器根据请求的URL交给DNS域名解析，找到真实 IP，向服务器发起请求；        
  	2. 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）;    
  	3. 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；    
  	4. 载入解析到的资源文件，渲染页面，完成。
* 前端性能优化的方法    
  * content方面
  1. 减少HTTP请求：合并文件、CSS精灵、inline Image
  2. 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
  3. 避免重定向：多余的中间访问
  4. 使Ajax可缓存
  5. 非必须组件延迟加载
  6. 未来所需组件预加载
  7. 减少DOM元素数量
  8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  9. 减少iframe数量
  10. 不要404
  * Server方面
  1. 使用CDN
  2. 添加Expires或者Cache-Control响应头
  3. 对组件使用Gzip压缩
  4. 配置ETag
  5. Flush Buffer Early
  6. Ajax使用GET进行请求
  7. 避免空src的img标签
  * Cookie方面
  1. 减小cookie大小
  2. 引入资源的域名不要包含cookie
  * css方面
  1. 将样式表放到页面顶部
  2. 不使用CSS表达式
  3. 使用link不使用@import
  4. 不使用IE的Filter
  * Javascript方面
  1. 将脚本放到页面底部
  2. 将javascript和css从外部引入
  3. 压缩javascript和css
  4. 删除不需要的脚本
  5. 减少DOM访问
  6. 合理设计事件监听器
  * 图片方面
  1. 优化图片：根据实际颜色需要选择色深、压缩
  2. 优化css sprite
  3. 不要在HTML中拉伸图片
  4. 保证favicon.ico小并且可缓存
  * 移动方面
  1. 保证组件小于25k
  2. Pack Components into a Multipart Document
* WEB应用从服务器主动推送Data到客户端有那些方式？
  > html5提供的Websocket(nodejs的socket.io)    
  不可见的iframe    
  WebSocket通过Flash    
  XHR长时间连接    
  XHR Multipart Streaming    
* SEO优化
  > 1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可    
  2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页    
  3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取    
  4.重要内容不要用js输出：爬虫不会执行js获取内容    
  5.少用iframe：搜索引擎不会抓取iframe中的内容    
  6.非装饰性图片必须加alt    
  7.提高网站速度：网站速度是搜索引擎排序的一个重要指标
* HTTP request报文结构是怎样的    
  1. 首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF
  2. 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束
  3. 请求头和消息实体之间有一个CRLF分隔
  4. 根据实际请求需要可能包含一个消息实体    
  一个请求报文例子如下：
  
  > GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1    
Host: www.w3.org    
Connection: keep-alive    
Cache-Control: max-age=0    
Accept: text/html,application/xhtml+xml,application/xml;    q=0.9,image/webp,*/*;q=0.8    
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)     AppleWebKit/537.36 (KHTML, like Gecko)     Chrome/35.0.1916.153 Safari/537.36    
Referer: https://www.google.com.hk/    
Accept-Encoding: gzip,deflate,sdch    
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6    
Cookie: authorstyle=yes    
If-None-Match: "2cc8-3e3073913b100"    
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT    
name=qiu&age=25
>

* HTTP response报文结构是怎样的  
1. 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF
2. 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部
3. 响应头部和响应实体之间用一个CRLF空行分隔
4. 最后是一个可能的消息实体 响应报文例子如下：
>HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT        
Server: Apache/2    
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT    
ETag: "40d7-3e3073913b100"    
Accept-Ranges: bytes    
Content-Length: 16599    
Cache-Control: max-age=21600    
Expires: Tue, 08 Jul 2014 11:28:43 GMT    
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"    
Content-Type: text/html; charset=iso-8859-1    
{"name": "qiu", "age": 25}    
>


